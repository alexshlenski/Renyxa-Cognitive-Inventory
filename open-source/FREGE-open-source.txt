=======================================================================
üî∏ FREGE MAIN PRINCIPLE: ATTENTION-DRIVEN SEMANTIC DOMINANCE
=======================================================================

All semantic links in this matrix obey a single global invariant called
the ‚ÄúAttention-Driven Semantic Dominance‚Äù.

Definition:
Every directed semantic link X ‚Üí Y MUST be oriented from the
semantically dominant term (the figure, focus, controller, governor,
or grounding reference) toward the semantically dependent term
(the ground, affected, constrained, referenced, or contextual frame).

Dominance is NOT uniform; it is determined locally by the relation family:

‚Ä¢ Causality            ‚Üí ontological dominance (cause ‚Üí effect)
‚Ä¢ Agency / Function    ‚Üí functional dominance (agent ‚Üí target)
‚Ä¢ Mereology            ‚Üí structural dominance (whole ‚Üí part)
‚Ä¢ Abstraction          ‚Üí ontological grounding (type ‚Üí instance)
‚Ä¢ Spatial relations    ‚Üí attentional dominance (figure ‚Üí ground)
‚Ä¢ Temporal relations   ‚Üí attentional dominance (focused event ‚Üí reference event)
‚Ä¢ Discourse (CNJ)      ‚Üí rhetorical dominance (anchor ‚Üí satellite)

Important:
‚Äì Size, power, enclosure, or physical magnitude do NOT determine direction.
‚Äì Attention / focus ALWAYS overrides ontological intuition where applicable.
‚Äì Passive, inverse, or ‚Äú_by‚Äù relations are forbidden.
‚Äì Relation names NEVER encode inversion; direction alone carries asymmetry.
‚Äì Allen relations are NOT exceptions: their selection and orientation
  are governed by attentional focus, not by time itself.

This invariant is global and mandatory.
Violations correspond to irony, absurdity, metaphor, or error and MUST
NOT appear in canonical representations.

======================================================================
üî∏ FREGE IDENTIFIERS
======================================================================

All FREGE structural elements are referred by identifiers produced by explicit and implicit declarations.

All identifiers in FREGE are assigned a type and a subtype at declaration, both explicit and implicit.  
The type of identifier is defined by the declaration block.


‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Entity    | Identifier format | Declaration block | 
======================================================================
Specific    e_s_<sbt>_*           ENB
Generic     e_g_<sbt>_*           implicit
Unique      e_u_<sbt>_*           implicit

Subtypes (sbt):

tng - tangible object 
inf - info object     
cnp - concept, mental object         
ent - fallback (if a specific subtype cannot be figured)

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Nominalization | Identifier format | Declaration block | 
======================================================================
Specific         n_s_<sbt>_*           ENB
Generic          n_g_<sbt>_*           implicit
Unique           n_u_<sbt>_*           implicit

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Circumstantial | Identifier format | Declaration block | 
======================================================================
Specific         c_s_<sbt>_*           CRB
Generic          c_g_<sbt>_*           implicit
Unique           c_u_<sbt>_*           implicit
Subtypes (sbt):

tmp - temporal
loc - locative
tpl - topology
env - environment
mnr - manner
csl - causal
prp - purpose
cnd - conditional
csv - concessive
ins - instrumental
acp - accompaniment
dgr - degree
evd - evidential
pst - perspectival

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Attribute   | Identifier format | Declaration block | 
======================================================================
Specific         a_s_<sbt>_*           ATB
Generic          a_g_<sbt>_*           implicit
Unique           a_u_<sbt>_*           implicit

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Discourse   | Identifier format | Declaration block | 
======================================================================
Generic          d_*                   implicit

No subtypes

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Event       | Identifier format | Declaration block | 
======================================================================
Declarative      Ev_*                EVT
Question         Eq_*                EVQ
Subjunctive      Es_*                EVS

No subtypes

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Set             | Identifier format | Declaration block | 
======================================================================
Always specific  s_<sbt>_*           EVT

Same subtypes as Entity.
 
‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
Relation        | Identifier format | Declaration block | 
======================================================================
Always specific  r_*                 REL

No subtypes
        
------------------------------------------------------------------
üî∏ FREGE MAIN ARCHITECTURAL PRINCIPLES:
======================================================================
RULE: Semantic Phrase Segmentation by Role Continuity
------------------------------------------------------------------
Definition:
A semantic phrase is the maximal contiguous span that answers one semantic role question.

Procedure:
1. When a role marker appears (e.g. with=instruments, in=location, at=time/place, for=purpose),
   open a semantic role and start a phrase.
2. Extend the phrase token-by-token as long as the accumulated span continues to answer
   the same role question and does not introduce a new role.
3. Do NOT terminate the phrase due to syntactic boundaries, repeated prepositions,
   modifiers (evidential, degree, hedge), or punctuation alone.
4. Terminate the phrase only when:
   a) the next token group no longer answers the original role question, or
   b) a new semantic role is opened, or
   c) the sentence ends.

Constraint:
If multiple surface groups collectively answer the same semantic role question,
they MUST be treated as a single semantic phrase.

Prohibition:
NP/PP/AP boundaries and syntactic constituency are irrelevant to phrase segmentation.
------------------------------------------------------------------
RULE: Only events that directly add to the source fabula are encoded with EVT/CPL, 
entity-related events and copulas must be encoded by microsemantic tools of ENB/CRB/APB
------------------------------------------------------------------

If a fact contributes directly to the narrative of the situation or event, it MUST be encoded as EVT or CPL.
If a fact is provided as internal detailing used to identify or characterize an entity, it MUST be encoded 
through microsemantics of ENB, CRB, and ATB blocks, and MUST NOT generate EVT or CPL.


======================================================================
üî∏ FREGE BLOCKS
======================================================================

FREGE is a declarative block language. Every semantic type in FREGE is declared by a specific block.
Complex semantics is expressed by relations between blocks.

======================================================================
üî∏ ENB-block ‚Äî Formal Syntax
======================================================================
MANDATORY: Nesting of ENB blocks is strictly prohibited!

ENB block can declare one of 3 types 

- Entity 
- Nominalization 
- Reification

The body of the ENB block describes the microsemantic exported by its surface.
Sometimes microsemantic requires creation of virtual notion v_* to describe the meaning
that the surface does not export explicitly but can be easily inferred using the LLM's vast world
knowledge. 

<ENB 
  ENT-ID: e_s_<sbt>_* | NOM-ID: n_s_<sbt>_*
  SURFACE: <surface syntagm>
  NS: axis1.axis2
  QT: each | every | all | some | most | few | ... // optional segment, only if the entity has quantifiers
  MSE:
      u_1: MSE_Unit_1 : semantic_role
      u_2: MSE_Unit_2 : semantic_role
      ...
      u_N: MSE_Unit_N : semantic_role
  LNK:
      u_N: SLK_link: u_M
      ...
      u_K: SLK_link: u_L
BNE>

where MSE_Unit::= EXACTLY ONE word or fixed phrase from surface | ENT-ID or NOM-ID or CIR-ID or ATR-ID declared by a delegate block | virtual notion

fixed phrase examples: "Soviet Union", "railroad crossing", "property tax", "state treason", "capital punishment", "vehicle registration renewal"

IF surface contains MORE THAN ONE word, which is not a fixed phrase MSE/LNK segments are MANDATORY!

MANDATORY RULES:
A subordinate clause or infinitive phrase should never be incorporated into the surface of ENB block. Infinitive must be encoded with HDL block and 
subordinate clause - with EVT block.

Examples:

order to fall back
idea to have a drink
desire to fly to Vegas
dream of becoming a waitress

------------------------------------------------------------------
4.5. ENB ‚Äî Entity Declaration Rules
------------------------------------------------------------------

If surface segment is a single word or a fixed expression, ENB block should
only contain the declaration part and have no MSE / LNK block.
Rationale: single words and fixed expression do not export microsemantics, 
thus structural blocks have nothing to describe.

Unique entities do not need explicit declaration. Do not create ENB blocks for 
unique entities.

Examples:
Sun, Moon, sky, the Earth, the Pacific Ocean, the Equator, Monday, August,
Spring, New Year‚Äôs Eve, Thanksgiving, the horizon, the speed of light,
the truth, the past, the future, Zeus, air, iron, the bible (as a holy text)

However the bible as a specific object (a book) needs an ENB.

Prepend unique entity ID with prefix `u_` before the entity type prefix `e_`. 

Examples:
u_e_Pacific_Ocean 
u_e_horizon 
u_e_Wednesday
u_e_August
u_e_future

Generic entities comprised of a single word or a fixed phrase also do not need
explicit declaration.

Prepend unique entity ID with prefix g_* before the entity type prefix `e_`.

Examples:

Perishable food must be kept in refrigerator.

e_g_perishable_food (fixed phrase)
e_g_refrigerator

Indefinite personal pronouns: 
someone / somebody
anyone / anybody
no one / nobody
everyone / everybody
one
ones
anyone
someone
no one
everyone
something
anything
nothing
everything
they / them / their
others
another
many
few 
several
some
all
none

are encoded as generic entities: e_g_somebody e_g_several, etc.
Their exact meaning can be only inferred from the context.

Specific entities comprised of multiple words, which are not fixed phrases require 
a full ENB block.

------------------------------------------------------------------
4.6. END-ID / NOM-ID usability
------------------------------------------------------------------

ENT-IDs and NOM-IDs declared by ENB blocks are fully qualified logical nodes.

They may appear in:

‚Ä¢ SBJ or OBJ of EVT, RTN, or CPL
‚Ä¢ membership lists of SET and QTF
‚Ä¢ in MSE blocks
‚Ä¢ LNK edges of nesting blocks

This enables deep semantic reuse of ES structures throughout the
FREGE-2 system.

------------------------------------------------------------------
4.9. Entity Scope and Reuse
------------------------------------------------------------------

Once declared, each `ENT-ID` becomes a globally accessible logical node
from the point of declaration through the remainder of the source text.

Rules:

‚Ä¢ If an Entity or Nominalization surface in a later sentence matches a previously 
  declared ENB block (both lexically and referentially), the Builder MUST NOT
  regenerate an ENB. Instead, the existing `ENT-ID` must be directly reused.

‚Ä¢ If the same surface form refers to a different referent, a new ENB block
  with a unique `ENT-ID` must be constructed. Disambiguation may
  involve differences in context, namespace, or MSE content.

This rule ensures identity propagation and semantic coherence
across distributed reference chains in the FREGE-2 profile.

------------------------------------------------------------------
4.10. ENB Application Scope
------------------------------------------------------------------

Create an ENB block for any noun phrase (ES) whose interpretation requires
internal semantic structure, embedded relations, scope layering, or
composition of multiple conceptual units. This includes all technical,
legal, military, administrative, scientific, and analytically dense NPs.

Do NOT create an MSE and LNK segments in the following cases:

‚Ä¢ The noun phrase consists of a single lexical word.
‚Ä¢ The noun phrase is a fixed multi-word expression that functions as an atomic unit.
‚Ä¢ The semantics of the phrase can be captured without any internal decomposition.

Example:

<ENB:
  ID: e_rain
  surface: "rain"
  NS: dom.weather.phenomenon
BNE>

<ENB:
  ID: e_railroad_crossing
  surface: "railroad crossing"
  NS: dom.transport.infrastructure
BNE>

======================================================================
üî∏ CRB block ‚Äî  Circumstantial
======================================================================
MANDATORY: Nesting of CRB blocks is strictly prohibited!

CRB encodes the microsemantic DAG of an circumstantial group (time, place,
manner, cause, condition, purpose, result, degree, concession, etc.).
It parallels ENB in structure and semantics.

Formal Syntax:

<CRB
  CIR-ID: c_node_id
  surface: "<original Circumtantial span>"
  CLS: time|place|manner|cause|condition|purpose|result|
       degree|concession|comparison|accompaniment|instrument
  DSC: discourse_modifier // optional: apparently, presumably, evidently, approximately, ...
  MSE-BLOCK // structurally and semantically the same as in ENB
BRC>

where 
‚Ä¢ `surface` preserves the exact circumstantial Circumtantial.
‚Ä¢ `ID` is the canonical logical identifier for this Circumtantial.
‚Ä¢ `CLS` defines the semantic class of the Circumtantial.

A CRB block may reference ENBs or other CRBs through ENT-ID / NOM-ID / CRB-ID 
identifiers to express stacked semantics. 

CRB declares Circumtantial ID that is referred in CRA block inside EVT block.

------------------------------------------------------------------
For this block and other blocks using DSC option, apply this "DSC vs Degree" rule:

Use DSC only for lexemes that explicitly encode the speaker‚Äôs epistemic or evidential stance toward the truth of a circumstance.
Lexemes that specify precision, extent, or position on a scale (degree, accuracy, granularity) MUST be encoded in MSE, not in DSC,
even if they pragmatically imply confidence.

Test:
‚Äì If the lexeme answers ‚Äúhow certain is the speaker?‚Äù, use DSC.
‚Äì If the lexeme answers ‚Äúhow precise / how much / to what extent?‚Äù, do NOT use DSC.

========================================
üî∏ ATB block ‚Äî Attribute Qualification Block
========================================

Purpose:
ATB encodes a structured (non-atomic) qualitative attribute as a
canonical, referencable semantic object.

Generic atomic attributes do not need declaration. They are declared implicitly 
by identifiers formatted as g_a_* (generic attribute).

Atomic attribites that export context related semantics (Tropes) need formal
declaration with an explanation in a single MSE line. 

Example:

Bastardized solution (engineering slang)

ATB answers the question "–ö–ê–ö–û–ô?" (not "–ö–ê–ö?") and never encodes manner, comparison,
circumstances, or events.

----------------------------------------
Formal Syntax
----------------------------------------
MANDATORY: Nesting of ATB blocks is strictly prohibited!

<ATB
  ATR-ID: a_*
  surface: "original attribute span"
  ATR: attribute_lemma
  AXS: semantic.axis.path
  DSC: discourse_modifier // optional: apparently, presumably, evidently, approximately, ...
  MSE-BLOCK // structurally and semantically the same as in ENB
BTA>

----------------------------------------
Atomic Attribute Rule (MANDATORY)
----------------------------------------

If an attribute is:
‚Ä¢ single-word
‚Ä¢ non-structured
‚Ä¢ not a trope

‚Üí encode as generic:
    ga_strong, ga_fast, ga_red

ATB MUST NOT be created for generic atomic attributes.

----------------------------------------
When ATB IS Required (MANDATORY)
----------------------------------------

ATB MUST be created if the attribute:
‚Ä¢ is multi-word or internally structured
‚Ä¢ requires microsemantic decomposition
‚Ä¢ must be referenced by identifier (a_*)
‚Ä¢ functions as a composed qualifier of an entity or state
‚Ä¢ exports context-related semantics (trope)

----------------------------------------
Ontological Constraints
----------------------------------------

ATB introduces an identifier (a_*), which is an obligatory terminal graph node.
Therefore,
‚Ä¢ ATB does NOT participate in CNJ or LGK
‚Ä¢ ATB has no independent scope
‚Ä¢ ATB is interpreted only through its host

----------------------------------------
ATB Variables (a_*) ‚Äî Legal Reference Scope
----------------------------------------

Identifiers declared by ATB (a_*) MAY be referenced ONLY in:

1) CPL ‚Äî Copular Predication Block  
   Role: predicate of state or state transition (‚Äúwhat kind‚Äù)

2) ENB  MSE ‚Äî Nominal Phrase Microsemantics  
   Role: intrinsic qualification of an entity

Attribute Identifiers (a_*) make no sense and are STRICTLY FORBIDDEN in:
‚Ä¢ EVT
‚Ä¢ CRB
‚Ä¢ REL
‚Ä¢ RTN
‚Ä¢ CNJ / LGK

Any forbidden occurrence INVALIDATES FSP.

----------------------------------------
Microsemantic Requirement
----------------------------------------

For structured (multi-word) attributes:
‚Ä¢ MSE block is MANDATORY
‚Ä¢ LNK block is MANDATORY
‚Ä¢ every surface token MUST be represented
‚Ä¢ microsemantic rules identical to ENB

----------------------------------------
Referencing Rules INSIDE ATB (as well as all other blocks)
----------------------------------------

Referenced identifiers must play a role compatible with the block‚Äôs ontological level 
and dominance direction.

----------------------------------------
Reference Examples (Canonical)
----------------------------------------

ATB declaration:
<ATB
  ID: a_mentally_resilient
  surface: "mentally resilient"
  ATR: resilient
  AXS: psychological.resilience
  MSE
  ...
BTA>

1) Reference from ENB :
<ENB
  ID: e_operator
  surface: "the mentally resilient operator"
  NS: dom.human.professional
  MSE
  ...
BNE>

2) Reference from CPL (state):
<CPL
  <SBJ: e_operator>
  <ATA: a_mentally_resilient>
PLC>

==============================================================
üî∏ ATA Block ‚Äî Attribute Application
==============================================================

ATA-BLOCK ::=
    <ATA: a_nodeid>

nodeid ::= a_* | g_a_*
  // a_*   : declared attribute identifier (ATB block)
  // g_a_* : generic atomic attribute (implicit, no ATB block)

ATA introduces the ‚óºAttribute node‚óº as a predicate of copular predication,
answering the question ‚Äú–ö–ê–ö–û–ô?‚Äù and asserting a qualitative state or
state transition of the subject.

MANDATORY RULE:
ATA block must be located ONLY in CPL block after ACT and OBJ blocks.
Placing ATA block in EVT, RTN, CRB, CNJ, or LGK invalidates FSP immediately.

Ontological Constraints:
‚Ä¢ ATA does NOT introduce new semantics
‚Ä¢ ATA references an already existing attribute identifier only
‚Ä¢ ATA has no independent scope
‚Ä¢ ATA does NOT modify realization or process
‚Ä¢ ATA is evaluated exclusively through the copula

Multiplicity Rule:
‚Ä¢ Multiple ATA blocks in one CPL are FORBIDDEN
‚Ä¢ Attribute composition MUST be performed in ATB

Normative Summary:
‚Ä¢ CRA applies circumstantials to events
‚Ä¢ ATA applies attributes to copular predication
‚Ä¢ CRA answers ‚Äú–ö–ê–ö?‚Äù
‚Ä¢ ATA answers ‚Äú–ö–ê–ö–û–ô?‚Äù

==============================================================
üî∏ CPL block ‚Äî Copular Predication (Classification & Attributes)
==============================================================

CPL encodes static, non-eventive, timeless facts about an entity.
Unlike EVT, CPL does not describe occurrences or changes. 
CPL declares:
‚Ä¢ what entity or nominalization is, 
‚Ä¢ what properties it has, 
‚Ä¢ what role it fulfills,
‚Ä¢ what it consists of, 
‚Ä¢ where it is situated by default,
‚Ä¢ how it is different or similar or the same as something else

CPL statements form part of the global semantic DAG but do NOT introduce
events or temporal structure.

--------------------------------------------------------------
5.1. CPL - Formal Syntax
--------------------------------------------------------------
MANDATORY: Nesting of ENB blocks is strictly prohibited!

Copula does not need ACT block because the only admitted verbs confined to
`is` and `are`.

If something `was` or `will be` or `become` or `appear to be` or 'made of', 
it is semantically a regular event because it is not stative.

CPL/EVT disambiguation:
If assertion can be interpreted as a result of an event, it is EVT, not CPL.

"Silver is metal" - CPL. It can not be viewed as event.
"A ring is made of silver" - EVT. Someone made it.
"Caterpillar became a butterfly" - EVT. It was a transformation.

<CPL:id=Cp_*
  <SBJ: node_id>
  <PRD: is_a | has_property | has role | has_status| consists_of | default_location | identical_to | 
  OBJ-BLOCK | ATA-BLOCK
PLC>

SBJ, OBJ, and ATA blocks are have the same structure and usage as in
EVT block.

MANDATORY RULE:
Do not use EVT block for static descriptions, use CPL block. EVT block 
is used only for dynamic desctiptions - actions and occurrences.

--------------------------------------------------------------
5.2. Semantics
--------------------------------------------------------------

A CPL asserts stable facts like:

Apple is fruit.
Life is good.
Jason has a bike.
Sky is blue.
Lucie is a waitress.
Pig is made of pork.
Car is in the garage.
Shark is larger than herring.
Lee's kungfu is almost as good as Chen's.

This relation is:

  ‚Ä¢ atemporal (not tied to an event)
  ‚Ä¢ stable or characteristic
  ‚Ä¢ non-procedural
  ‚Ä¢ part of the subject‚Äôs descriptive profile

CPL is used for:

  ‚Ä¢ classification (‚ÄúX is a Y‚Äù)
  ‚Ä¢ intrinsic/extrinsic attributes
  ‚Ä¢ stable roles and functions
  ‚Ä¢ origin, nationality, affiliation
  ‚Ä¢ physical composition (material, parts)
  ‚Ä¢ stable location (headquarters, base)
  ‚Ä¢ identity, difference and equivalence

--------------------------------------------------------------
5.8. When CPL Must Be Used (Mandatory Conditions)
--------------------------------------------------------------

Use CPL instead of EVT when:

  ‚Ä¢ the meaning is non-eventive
  ‚Ä¢ nothing changes or happens
  ‚Ä¢ the copula or role/function is nominal
  ‚Ä¢ the classification is stable
  ‚Ä¢ the semantics describes a state without temporal anchoring

This keeps the global DAG clean, separates facts from events,
and preserves reversibility.

======================================================================
üî∏ REL Block ‚Äî Relation Description 
======================================================================

Purpose:
The REL block encodes relations between notions including but not limited to comparison, subordination, dependency, transformation stages, etc.

Syntax:
<REL
  REL-ID: r_*
  RLF: related from ID
  RLT: related to ID
  AXS: the semantic dimension where the relation takes place
  SRF: "surface phrase"
  MSE:
      u_N: MSE_Unit_N: semantic_role
      ...
      u_M: MSE_Unit_M: semantic_role
  LNK:
      u_N: SLK_link: u_M
      ...
      u_K: SLK_link: u_L
LER>

RLF and RLT can be the identifiers of 
Entity - e_*
Event  - Ev_*
Event subject - Ev_*:SBJ
Event object - Ev_*:OBJ:N where N is the ordinal number of the OBJ segment in the EVT/EVS/EVQ block 

Semantics: 
REL asserts that CMF relates to CMT the way that SFR has expressed and analyzed by MSE/LNK.

Interpretation Direction:
Relation is always from CMF toward CMT. This preserves polarity and rhetorical force.


======================================================================
üî∏ HDL block ‚Äî Headless Action
======================================================================

HDL block declares H_* identifier that is licensed in CNJ block as a first class semantic node. 
It uses particle $to as a connector with other identifiers.

----------------------------------------------------------------------
Formal Syntax
----------------------------------------------------------------------

<HDL  
  HDL-ID: H_*  
  surface: "<infinitival span>"  
  CLS: purpose | reason | condition | result | enablement  
       | expectation | content | directive | evaluation  
LHD>

----------------------------------------------------------------------
Semantic Classes
----------------------------------------------------------------------

‚ú¶ purpose  
Explains intended goal.  
*He stopped to rest.*

‚ú¶ result  
Unintended or inevitable outcome.  
*She grew up to become a doctor.*

‚ú¶ expectation / intended outcome  
Often after nouns/adjectives, but HDL applies only when headless.  
*To expand the line, capacity must be increased.*

‚ú¶ content / proposition  
Purely propositional meaning.  
*To leave now would be unwise.*

‚ú¶ directive / instructional  
Action framed as instruction without a governing verb.  
*To wait any longer is pointless.*

‚ú¶ evaluation / judgment  
Carries an evaluative stance.  
*To believe that now is difficult.*

‚ú¶ reason / justification  
Explains why something is done.  
*To avoid confusion, let me clarify.*

‚ú¶ condition / requirement  
Prerequisite for the main clause.  
*To qualify, you must register early.*

‚ú¶ enablement  
States a capability or enabling condition.  
*To be able to proceed, authentication is required.*

----------------------------------------------------------------------
Usage Rules
----------------------------------------------------------------------

Create HDL only when the infinitival clause is not semantically internal to an entity 
description contributes and belongs to the fabula-level event structure, expressing 
‚ú¶ purpose,
‚ú¶ reason,
‚ú¶ result,
‚ú¶ enablement,
‚ú¶ workflow step,
‚ú¶ evaluation,
‚ú¶ propositional content,
or any clause-level adjunct affecting the fabula.

Do NOT create HDL ehenever the infinitival phrase is local, i.e.:
‚ú¶ describes how an entity is positioned,
‚ú¶ encodes manner, configuration, orientation,
‚ú¶ expresses a local property of an object or participant,
‚ú¶ belongs to a participial phrase that characterizes an NP,
or is otherwise part of entity phrase,

In that case encode it as part of the ENB/CRB/ATB microsemantic decomposition of that 
entity segment.

======================================================================
üî∏ EVT/EVQ/EVS Blocks ‚Äî unified event descritor
======================================================================
MANDATORY: Nesting of EVT blocks is strictly prohibited!

This section defines the *canonical* event‚Äìlevel representation in FREGE-2.1.
The EVT block expresses ‚óºpredicate‚Äìargument structure‚óº, preserving:

  ‚Ä¢ surface lexical material (SBJ literal, ACT lemma, PRP prepositions),  
  ‚Ä¢ normalized semantic structure (SLK),  
  ‚Ä¢ canonical DAG edges SBJ ‚ÄîSLK‚Üí OBJ,  
  ‚Ä¢ tense/aspect/modality of the event.

EVT is strictly declarative at the argument level and non-procedural:
inter-event logical relations are handled by EDG (¬ß5.x).

Formal Syntax

Use EVT block for declarative statements.
Use EVQ/EVS blocks for questions.

MANDATORY: 
In the interrogative sentence in the question clause the verb mood in ACT block 
must be ITRG and the block must be EVQ (question). All other event blocks must 
use SUJT mood and the block must be EVS (subjunctive).

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
EVT Block:

EVT-block::= 
  <EVT:id=Ev_*
    SBJ-BLOCK
    ACT-BLOCK
    OBJ-BLOCK 
    CRA-BLOCK
  TVE>

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
EVQ Block:

EVQ-block::= 
  <EVQ:id=Eq_*
    SBJ-BLOCK
    ACT-BLOCK
    OBJ-BLOCK 
    CRA-BLOCK
  QVE>

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
EVS Block:

EVS-block::= 
  <EVS:id=Es_*
    SBJ-BLOCK
    ACT-BLOCK
    OBJ-BLOCK 
    CRA-BLOCK
  SVE>

All components share a unified structure and must obey the following
production rules:

MANDATORY RULE:
EVT block is used only for dynamic desctiptions - actions and occurrences.
For any type of static description use CPL block.

------------------------------------------------------------
RULE: Structured Verb Governance via CRB
------------------------------------------------------------
If a verb‚Äôs governance does not introduce independent arguments, but instead
establishes a structural relationship among multiple complements
(e.g. through prepositions, case marking, or other relational markers),
the compiler MUST NOT attach these complements as multiple OBJ entries
within the EVT block.

Instead, the compiler MUST:

1. Create a single CRB representing the internal semantic structure
   of the verb‚Äôs governance.
2. Place all governed complements inside this CRB.
3. Explicitly encode their semantic roles and relations within the CRB.
4. Attach the CRB to the EVT via a single CRA.

Rationale:
- OBJ slots are atomic participants of an event, not carriers of
  inter-complement structure.
- Structural relations among complements belong to circumstantial
  configuration, not to event argument listing.
- This rule ensures language-independent normalization and prevents
  accidental reliance on surface markers (prepositions, cases).

Corollary:
If complements can be reordered, removed, or interpreted only in relation
to each other (rather than independently), they MUST be compiled into a CRB.

======================================================================
üî∏ SBJ Block - The topological structure of event subject in ≈Åukasiewicz Notation
======================================================================

SBJ-BLOCK ::= 
    <SBJ: nodeid_K | <connector> nodeid_N  [ nodeid_M ... ] [ <connector> nodeid_O  [ nodeid_P ... ] ] >

where
nodeid ::= e_* | s_* | f_*     // entity, set/collection, or formal parameter

<connector> ::= $<original_surface_connector_as_snake>

SBJ introduces the ‚óºsubject group‚óº of the event.  
No prepositions or SLKs appear here; all relations involving SBJ occur inside OBJ blocks.

======================================================================
üî∏ CRA Block - Circumtantial Application
======================================================================

CRA-BLOCK ::= 
    <CRA: c_nodeid CLS: semantic_class>

nodeid ::= c_* | d_*
  // c_* : Circumtantial nodeid declared in CRB block
  // d_* : discourse Circumtantial constant (no CRB block)

CRA introduces the ‚óºCircumtantial node‚óº pertaining to the event or copula.

MANDATORY RULE:
CRA block must be located in EVT or RTN block after the OBJ blocks. 
Placing CRA block to any other location invalidates FSP immediately.

Discourse Circumtantials are special nodes filled with unary discourse
operators that are constants (like entity singletons) and do not require
a CRB block. Their CLS values are listed below.

CLS: discourse.evid    // Evidential: truth-status qualifiers
------------------------------------------------------------
apparently
evidently
seemingly
ostensibly
reportedly
allegedly
supposedly
purportedly
presumably

CLS: discourse.quant   // Coverage / scope qualifiers
------------------------------------------------------------
mostly
predominantly
largely
broadly
generally

CLS: discourse.attitude   // Assertion-strength / confidence markers
------------------------------------------------------------
undoubtedly
certainly

CLS: discourse.infer   // Unary inferential: derived, not observed
------------------------------------------------------------
logically
accordingly
consequently
thus        // unary use only, not Circumtantial CNJ

Examples of discourse CRA blocks:

<CRA: d_presumably_1 CLS: discourse.evid>

<CRA: d_certainly_1 CLS: discourse.attitude>

======================================================================
üî∏ ACT Block 
======================================================================

The ACT verb is fully described by a Verb Configurator:

Tense:Aspect:Voice:Mood:Modality:Polarity lemma

Where

TNS::= PAST | PRST | FUTR | FUPT                 // past, present, future, future-in-the-past
ASP::= INDF | HABT | CONT | PERF | PFCT      // indefinite, habitual, continuous, perfect, perfect continuous
VCE::= ACTV | PSSV                        // active, passive
MOO::= IDCT | ITRG | IMPT | SUJT            // indicative, interrogative, imperative, subjunctive
MDL::= NIL  | CAN  | CLD  | MAY  | MHT  | MST  | SHD  | WLL  | WLD  | OGT  | HVT // can, could, may, might, should, will, would, ought to, have to
PLR::= POS |NEG                         // positive, negative

use INDF for a single event and HABT for periodic events that occurs habitually.
use ITRG only at face value, for QUESTIONS, and nothing else.
use IMPT just as imperative - –ø–æ–≤–µ–ª–∏—Ç–µ–ª—å–Ω–æ–µ –Ω–∞–∫–ª–æ–Ω–µ–Ω–∏–µ, nothing else.
use SUJT just as subjunctive - —Å–æ—Å–ª–∞–≥–∞—Ç–µ–ª—å–Ω–æ–µ –Ω–∞–∫–ª–æ–Ω–µ–Ω–∏–µ, nothing else.

ACT-BLOCK ::= <ACT:TNS:ASP:VCE:MOO:MDL:PLR lemma>

MANDATORY RULE:
Only phrasal verbs are allowed preposition as a postix.

‚úÖ lemma: look_for - allowed.
‚ùå lemma: look_at  - prohibited.
‚úÖ lemma: come_by  - allowed.
‚ùå lemma: come_to  - prohibited.

Examples:

<ACT:PAST:INDF:ACTV:IDCT:NIL:POS remind> reminded
<ACT:PAST:INDF:ACTV:IDCT:NIL:NEG remind> did not remind
<ACT:PAST:INDF:PSSV:IDCT:NIL:POS remind> was reminded
<ACT:PAST:INDF:PSSV:IDCT:NIL:NEG remind> was not reminded
<ACT:PAST:PERF:PSSV:IDCT:NIL:POS remind> should have been reminded

<ACT:PRST:COTN:ACTV:IDCT:NIL:NEG listen> is not listening

======================================================================
üî∏ Extended ACT Block - infinitival complement, gerund, and participle
======================================================================

If the verb group includes infinitival complement, gerund, or participle, and the verb 
in one of those contructions semantically prepares, enables, or evaluates the second 
action, encode it with the extended code block:

ACT-BLOCK ::=
    <ACT:TNS:ASP:VCE:MOO:MDL:PLR lemma INF:infinitive-lemma PRN:preparation-type AGC:agency-type RLZ: realization type>
    |
    <ACT:TNS:ASP:VCE:MOO:MDL:PLR lemma GRN:gerund-lemma PRN:preparation-type AGC:agency-type RLZ: realization type>
    |
    <ACT:TNS:ASP:VCE:MOO:MDL:PLR lemma PTC:participle-lemma PRN:preparation-type AGC:agency-type RLZ: realization type>

Otherwise, summon the subject from the regular clause to compensate for the elided subject in the infinitive / gerund /
participle group, create regular EVT blocks and link them in DAG with regular CNJ connector.
    
Use the following matrix as a blueprint to build the extended part:

+------------------+----------------------------------------------------------+------------------------+--------------------+
| Preparation Type | Control Verbs Examples                                   | Agency                 | Realization        |
+------------------+----------------------------------------------------------+------------------------+--------------------+
| intention        | decide to, plan to, intend to, aim to                    | internal               | projected          |
| commitment       | promise to, swear to, pledge to                          | internal               | projected          |
| consent          | agree to, consent to, acquiesce to                       | distributed            | projected          |
| attempt          | try to, attempt to, struggle to, endeavor to             | internal               | projected          |
| preparation      | get ready to, prepare to, be poised to                   | internal               | projected          |
| desire           | want to, wish to, hope to, long to                       | internal               | projected          |
| inducement       | persuade to, convince to, urge to                        | external               | projected (by ext) |
| permission       | allow to, permit to, authorize to                        | external               | projected          |
| obligation       | need to, be obliged to, be supposed to, be expected to   | distributed            | projected          |
| ability          | be able to, manage to, fail to (inability)               | internal               | context-dependent  |
| volition         | choose to, volunteer to, refuse to                       | internal               | projected          |
| causation        | cause to, force to, lead to                              | external               | asserted           |
| aspect           | begin to, continue to, cease to                          | internal               | asserted           |
| frustration      | try to, threaten to (blocked attempt)                    | internal               | projected          |
| omission         | forget to, neglect to, fail to (omission)                | internal               | unrealized         |
| success          | manage to, succeed in                                    | internal               | asserted           |
| stance           | fear to, hesitate to, dread to                           | internal               | projected          |
| simulation       | pretend to, claim to, purport to                         | internal               | fictive            |
+------------------+----------------------------------------------------------+------------------------+--------------------+

Example:

<EVT:id=E4
  <SBJ: e_bellingcat>
  <ACT:PAST:INDF:ACTV:IDCT:NIL:POS decide INF:film PRN:intention AGC:internal RLZ: projected>
  <OBJ: e_documentary
       PRP=NIL
       SLK=has.object
  JBO>
TVE>

======================================================================
üî∏ OBJ Block (Unified Complement Structure)
======================================================================

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
OBJ block with entity, set, and formal entity parameter object: 

OBJ-BLOCK ::=
    <OBJ: nodeid_K | <connector> nodeid_N  [ nodeid_M ... ] [ <connector> nodeid_O  [ nodeid_P ... ] ]
       PRP=preposition_or_NIL
       SLK=semantic_link
    JBO>

Where:
  <connector> ::= $<original_surface_connector_as_snake>

  nodeid ::= e_* | s_* | f_*
  preposition_or_NIL ::= "lexical_preposition" | NIL  
  semantic_link ::= one SLK from unified kernel (¬ß5.x)
  
MANDATORY: 
Only entity, set, or formal parameter are admitted in OBJ block as a node.
Using EVT or CNJ as entity inside OBJ block disqualfies you immediately!

SEMANTICS DIRECTION:

  SBJ  --SLK-->  OBJ

PRP preserves the surface form ‚óºexactly as it reads in the source text‚óº.  
SLK provides ‚óºcanonical abstract semantics‚óº.

Examples:

  Direct object (no preposition):
    <OBJ: e_patient
         PRP=NIL
         SLK=affects
    JBO>

  Prepositional complement:
    <OBJ: e_childhood
         PRP="of"
         SLK=has.association
    JBO>

  Instrumental/means:
    <OBJ: e_knife
         PRP="with"
         SLK=uses.resource
    JBO>

Multiple OBJ-BLOCKs may appear in any EVT when the verb licenses multiple arguments.


MANDATORY RULE:
If a single subject performs one action (ACT) simultaneously affecting multiple objects, all objects must be represented 
as separate <OBJ> blocks within a single <EVT> block, not as separate events.
Do not create multiple EVT blocks for what is a single event with multiple objects.

Example:

The maid went from the bedroom through the living room to the kitchen.

  <EVT:id=e_maid
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS go>
    <OBJ: e_bedroom
         PRP="from"
         SLK=spacial.direction
    JBO>
    <OBJ: e_living_room
         PRP="through"
         SLK=spacial.direction
    JBO>
    <OBJ: e_kitchen
         PRP="to"
         SLK=spacial.direction
    JBO>
  TVE>

Incorrect:
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS go>
    <OBJ: e_bedroom
...
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS go>
    <OBJ: e_living_room
...
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS go>
    <OBJ: e_kitchen

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
OBJ block with event pointer object (AKA propositional anaphora): 

OBJ-BLOCK ::=
    <OBJ: Ev_ID
          PRP=preposition_or_NIL
          PTR=event_pointer
          SLK=semantic_link
          [QTY>N | QTY>=N | QTY<N | QTY<=N | N<QTY<M | N<=QTY<=M | N<QTY<=M | N<=QTY<M QTY=<arbitraty phrase>]
    JBO>

Where:

  nodeid ::= Ev_* |Eq_* |Es_*
  preposition_or_NIL ::= "lexical_preposition" | NIL  
  event_pointer ::= pronoun/anaphora that semantically points to the Ev_ID
  semantic_link ::= one SLK from unified kernel (¬ß5.x) If relevance not found, invent one.
  
MANDATORY:
‚ú¶ PTR may only bind nominal (referential) `that` that points to an event clause as a sort of nominalization.
‚ú¶ Complementizer `that` that links event clauses like a conjunction MUST NOT appear in OBJ.
‚ú¶ Complementizer `that` is encoded exclusively as CNJ.

‚ú¶ If `that` appears in OBJ, it MUST be referential and MUST resolve to an Ev/Eq/Es node.  

------------------------------------------------------------
4.x.5 Overall EVT Structure ‚Äî Example
------------------------------------------------------------

Source:
  ‚ÄúThe smell reminded Nathan of his childhood.‚Äù

Representation:
  <EVT:id=Ev_01
      <SBJ: e_smell>
      <ACT:PAST:INDF:ACTV:IDCT:NIL:POS remind>

      <OBJ: e_Nathan
           PRP=NIL
           SLK=affects
      JBO>

      <OBJ: e_childhood
           PRP="of"
           SLK=has.association
      JBO>
  TVE>

Interpretation:
  SBJ (smell) affects Nathan  
  SBJ (smell) has.association childhood  

------------------------------------------------------------
4.x.6 Notes and Constraints
------------------------------------------------------------

1. Every semantic argument of ACT must appear as an OBJ block.
2. PRP is always preserved; it enables perfect reversibility.
3. SLK must come from the unified declarative kernel.
4. OBJ blocks form a ‚óºsubject-anchored relational fan-out‚óº, yielding a
   DAG of SBJ ‚Üí OBJ edges.
5. No SLK appears inside the ACT block. The verb is not the semantic
   link; the verb merely *selects* SLKs via lexical/PRP mapping.
6. Prepositions never map directly to SLK in the final representation:
   PRP is surface, SLK is deep structure.

------------------------------------------------------------
4.x.7 EVT as the Bridge Layer
------------------------------------------------------------

EVT links:

  ‚Ä¢ surface syntax ‚Üí semantic graph
  ‚Ä¢ lexical combinatorics ‚Üí canonical SLK relations
  ‚Ä¢ sentence structure ‚Üí entity graph

EVT is declarative at the argument level and does not handle discourse
logic.

======================================================================
üî∏ CNJ block ‚Äî The topological structure of events in ≈Åukasiewicz Notation
======================================================================

The CNJ block reflects the exact event topology from the surface using the
original conjunctions, complementizers and other lexical units that the
surface uses to create an algebraic structure of links between events, 
copulas and relations.

CNJ can accommodate the following blocks: CPL,EVT, RTN, REL

There must nbe exactly one CNJ block per DFS.

Formal Syntax:
‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí

CNJ-BLOCK ::= Ev_Event_K | <connector> Ev_Event_N  [ Ev_Event_M ... ] [ <connector> Ev_Event_O  [ Ev_Event_P ... ] ]
           
where 
<connector>::= 
  $<original_surface_connector_as_snake> |
  $<complementizer> |
  CTL-ID
  
 complementizer::= that | whether | if | ...

Connectors in CNJ are not logical, they are ppropositional.

MANDATORY RULES:
All connectors in CNJ must abide by ≈Åukasiewicz Notation in terms in topological sense.
All CNJ-level nodes declared in DFS must appear in CNJ exactly once.
Free standing nodes and free hanging connectors render CNJ block and the entire DFS invalid.
A comma connector `,` that connects clauses in surface must be replaced with $and in CNJ block.

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí

Example that exports complementizer:
- Ann hoped THAT Andy won't leave her.
  
‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
CTL-ID declaration and usage

CTL-block:==
  <CTL
    CTL-ID: ctl_<snake_connected_surface>
    surface: e_* ID from SBJ from the subject of controlong caluse that introduces and controls the subordinate clause
  LTC>

The subject of the controlling clause subordinates the the subordinate clause by creating
the ontological space where subordinate clauses's event occurs. 

The syntax is: <ontological space> + <complementizer>

The types of ontological space are included but not limited to those examples:

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
‚ú¶ time object:

Example:   
There were *ontological_space:[times] *complementizer:[when] the price of a gallon of milk was only 99 cent.
There will come *ontological_space:[the blessed time] *complementizer:[when] everyone will be free.

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
‚ú¶ space object:

Example:   
We don't have *ontological_space:[enough room] in this parking lot *complementizer:[to] park our van.
The island was a long strip of *ontological_space:[barren land] *complementizer:[where] nobody lived except for the lighthouse keeper.

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
‚ú¶ enabler object:

Tim has bought *ontological_space:[a lathe] *complementizer:[with which] he could extend his woodwork business.

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
‚ú¶ communication object:

Example:   
Donna could not forgive her brother for *ontological_space:[his words] *complementizer:[that] her son Danny will never become a real man and get a job.   

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
‚ú¶ mental object:

Example:   
Emma had a *ontological_space:[weird dream] *complementizer:[that] she became a squirrel and climbed to the top of an oak tree.

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
‚ú¶ information object: 

Example:   
Richard received *ontological_space:[an email from his bank] *complementizer:[that] he was preselected for a home equity loan.

‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí

CNJ can accommodate the following blocks: CPL,EVT, RTN, REL

======================================================================
üî∏ CNJ SURFACE OPERATORS  (surface-bound; no abstract connectors) 
   Classification is by surface function. 
   Operators are tokens/phrases as they appear (snake_case). 
   Examples are illustrative; inventory is open-ended.
======================================================================
1) coordination and list-building
======================================================================
and
or
nor
as_well_as
along_with
plus
together_with
as_also
both_and
either_or
neither_nor
not_only_but_also

======================================================================
2) subordination and clausal embedding (complementizers / content-linkers)
======================================================================
that
whether
if
wh_what
wh_who
wh_whom
wh_which
wh_where
wh_when
wh_why
wh_how

======================================================================
3) adverbial clause introducers (time, condition, concession, reason, purpose, result)
======================================================================
# time / sequence
when
whenever
while
as
as_soon_as
once
until
till
before
after
since
now_that
by_the_time
the_moment
as_long_as

# condition / contingency
if
unless
provided_that
providing_that
as_long_as
on_condition_that
in_case
in_case_of
supposing
assuming
given_that
even_if
only_if

# concession / contrast (operator-like)
though
although
even_though
whereas
while_contrast
despite_that
in_spite_of_that
granted_that

# reason / explanation
because
since_reason
as_reason
given_that
seeing_that
for_the_reason_that

# purpose
so_that
in_order_that
lest

# result / consequence
so
so_that_result
so_much_that
such_that
therefore
thus
hence
consequently
as_a_result

======================================================================
4) relative clause introducers / relativizers
======================================================================
who
whom
which
that_rel
whose
where_rel
when_rel
why_rel
of_which
to_whom
in_which
by_which

======================================================================
5) comparison and scalar operators
======================================================================
than
as_as
not_as_as
as_..._as
more_than
less_than
rather_than
instead_of
like
unlike
similar_to
different_from

======================================================================
6) alternative, exception, restriction
======================================================================
except
except_that
except_for
other_than
rather_than
instead
only
just
merely
at_least
at_most

======================================================================
7) discourse-structuring markers (surface anchors; keep only if you still want cnj)
======================================================================
however
nevertheless
nonetheless
still
yet
on_the_other_hand
by_contrast
instead
otherwise
moreover
furthermore
also
besides
in_addition
for_example
for_instance
in_particular
namely
that_is
in_other_words
in_sum
overall

======================================================================
8) evidential / report / stance operators (surface unary; often best as crb d_* not cnj)
======================================================================
apparently
reportedly
allegedly
supposedly
purportedly
presumably
seemingly
ostensibly
evidently
clearly
certainly
undoubtedly
probably
likely
unlikely
maybe
perhaps

======================================================================
9) free-choice concessive operators (your new primitives; unary over degree/manner/etc.)
======================================================================
no_matter_how
no_matter_what
no_matter_who
no_matter_where
no_matter_when
no_matter_which
regardless_of_how
regardless_of_what
regardless_of_whether
irrespective_of_how
come_what_may
whatever
whoever
wherever
whenever
however_much
however_many
however_long

======================================================================
10) counterfactual / modal framing (surface operators)
======================================================================
as_if
as_though
if_only
would_that
suppose
supposing_that
imagine_that

======================================================================
11) quotation / speech framing (surface clause linkers)
======================================================================
quote
unquote
according_to
as_claimed_by
as_reported_by
as_stated_by

======================================================================
12) punctuation operators (optional; only if you treat punctuation as cnj surface)
======================================================================
comma
semicolon
dash
colon
paren_open
paren_close
quote_open
quote_close


‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
======================================================================
üî∏ SLK CONNECTORS (MICROSEMANTIC)
======================================================================
These relations cover identity, taxonomy, structure, quantity, quality,
possession, spatial topology, motion, evaluation, perception,
communication, and any microsemantic needed for evt/cpl/enb/crb/atb.

======================================================================
identity, taxonomy, similarity
======================================================================
is_a
subtype_of
instance_of
identical_to
similar_to
alias_of

======================================================================
structure / mereology
======================================================================
has_part
part_of
composed_of
layer_of
segment_of

======================================================================
quantity / measure
======================================================================
has_quantity
has_unit
count
fraction_of
percentage_of
bounded_by

======================================================================
evaluation / polarity
======================================================================
positive
negative
important
dangerous
useful
irrelevant

======================================================================
attributes, states, material properties
======================================================================
has_attribute
has_state
has_status
has_value
is_colored
is_shaped
is_made_of
has_temperature

======================================================================
possession, control, access
======================================================================
owns
controls
assigned_to
access_to

======================================================================
spatial (attention-driven: figure > ground)
======================================================================
at
inside
outside
on
near
adjacent_to
above
below
from
to
through
across
between

# topological (rcc-style)
disjoint_from
touching
overlapping
contained_in
equal_region

# boundary / exotic
partially_inside
protrudes_out_of
recessed_into
straddles_boundary
surrounds

# motion / path
enters
exits
approaches
recedes_from
circles_around
intersects_path

======================================================================
perception & communication
======================================================================
perceives
communicates
refers_to
describes

======================================================================
free-choice, concessive, surface-bound unary operators
======================================================================
no_matter_how
no_matter_what
no_matter_where
however
whatever
whichever

======================================================================
purpose, intention, internal causal nuance (microsemantic only)
======================================================================
aims_at
intends
desires
motivates
enables
prevents
facilitates

======================================================================
emotion, attitude, stance (microsemantic-only)
======================================================================
likes
dislikes
fears
trusts
suspects
expects
prefers

======================================================================
social / institutional relations
======================================================================
employs
reports_to
member_of
part_of_group
authorized_for

======================================================================
information structure (non-discourse)
======================================================================
focus_on
background_of
about

======================================================================

-----------------------------------
GATE LOGIC :
-----------------------------------

In FREGE-2.1 gate logic cascased are used only with RTN and QTF blocks
and never with EVT blocks.

Logical gate nodes (AND_n, OR_n, etc.) are implicitly declared at their 
first use as the TO target of an LGK block.

<LGK logical_connector_N [NOT] event_1 [NOT] event_2 ... [NOT] event_M KGL>

Examples:

<LGK AND_1 E1 E2 NOT E3 E4 KGL>
<LGK OR_1 AND_1 E5 E6 KGL>
<LGK AND_2 OR_1 E6 E7 KGL>
<LGK EQ E8 AND_2 KGL>
<LGK EQ E10 NOT E8 KGL>

Any other grouping block (e.g., <AND_2>...</AND_2>) is non-canonical.

--------------------------------------------------------------
6. SETS, QUANTIFIERS, AND SELECTION
--------------------------------------------------------------

A quantifier block has to be created when the surface does not describe
an entity directly but instead defines it indirectly via a set of conditions.

Examples:

Need quantifiers:
- All units in a radius of two clicks
- There is a passenger in the bus who did not buy the ticket.

Don't need quantifiers:
- All tactical units
- A transit passenger

------------------------------
6.1 Universal quantifier
------------------------------

Formal syntax:

<QTF 
  Q=ALL 
  SET:s_setname 
  PRM:f_param 
  NS:dom.axis1.axis2 
  SEL:Ev_1

  <CPL:id=Cp_1
    [<SBJ: f_param>]
    [<ATA: a_attribute>]
    ...
  TVE>

  <EVT:id=Ev_1
    [<SBJ: f_param>]
    [<ACT: ...>]
    [<OBJ: f_param>]
    [<CRA: f_param>]
    ...
  TVE>
FTQ>

<QTF 
  Q=ALL 
  SET:s_setname 
  PRM:f_param 
  NS:dom.axis1.axis2 
  SEL:Ev_my_select

  <CPL:id=Cp_1
    [<SBJ: f_param>]
    [<ATA: a_attribute>]
    ...
  TVE>

  <EVT:id=Ev_1
    [<SBJ: f_param>]
    [<ACT: ...>]
    [<OBJ: f_param>]
    [<CRA: f_param>]
    ...
  TVE>

  <EVT:id=Ev_2
    [<SBJ: f_param>]
    [<ACT: ...>]
    [<OBJ: f_param>]
    [<CRA: f_param>]
    ...
  TVE>

  ...
  <EVT:id=Ev_N
    [<SBJ: f_param>]
    [<ACT: ...>]
    [<OBJ: f_param>]
    [<CRA: f_param>]
    ...
  TVE>

  <LGK OR_K Ev_1 Ev_2 KGL>
  <LGK AND_L OR_1 Ev_3 Ev_4 KGL>
  ...
  <LGK Ev_my_select EQ AND_Final Cp_1 AND_L KGL>
FTQ>

------------------------------
6.2 Existential quantifier
------------------------------

<QTF 
  Q=EXIST 
  PTR:x_pointer
  PRM:f_param 
  NS:dom.axis1.axis2 
  SEL:Ev_1

  <EVT:id=Ev_1
    [<SBJ: f_param>]
    [<OBJ: f_param>]
    [<CRA: f_param>]
    ...
  TVE>
FTQ>

Where:

  ‚Ä¢ Ev_1..Ev_N     ‚Äì atomic selection events.
  ‚Ä¢ LGK blocks   - logically cascade atomic selection events 
  ‚Ä¢ Ev_my_select  ‚Äì final selection event
  ‚Ä¢ s_setname    ‚Äì identifier of set defined by universal quantifier
  ‚Ä¢ x_pointer    - identifier of entity defined by existential quantifier
  ‚Ä¢ f_param      ‚Äì formal parameter (f_*) ranging over entities.
  ‚Ä¢ NS::...      ‚Äì namespace classifier for the parameter.
  ‚Ä¢ QTF          ‚Äì quantifier specification.

Event ID under the SEL tag must reference an event_id within the quantifier scope
defined either by EVT block or LGK block.

------------------------------
6.3 Quantifier Application Scope
------------------------------
A QTF block is required if and only if a variable defined by a quantifier‚Äî
either a set variable introduced by a universal quantifier (SET) or a pointer 
introduced by an existential quantifier (PTR)‚Äîis used at least once outside 
the scope of the QTF block in which it is defined.

If the variable is not used outside the QTF scope, surface determiners 
(e.g., ‚Äúsome‚Äù, ‚Äúany‚Äù, ‚Äúmany‚Äù, etc.) must be represented via ENB 
micro-semantics rather than through a QTF block.

------------------------------
6.4 Quantifier Examples
------------------------------
Ex.1
Surface:
All field agents who submitted reports late will receive a notice.

FSP:

<ENB
  ID: e_notice
  surface: "a notice"
  NS: dom.intelligence.communication
BNE>

<ENB
  ID: e_report
  surface: "reports"
  NS: dom.intelligence.documentation
BNE>

<QTF 
  Q=ALL 
  SET:s_agents_late 
  PRM:f_agent 
  NS:dom.intelligence.personnel 
  SEL:Ev_1

  <EVT:id=Ev_1
    <SBJ: f_agent>
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS submit>
    <OBJ: e_report
         PRP=NIL
         SLK=has.object
    JBO>
    <CRA: t_late CLS: manner>
  TVE>
FTQ>

<EVT:id=Ev_2
  <SBJ: s_agents_late>
  <ACT:FUTR:INDF:ACTV:IDCT:NIL:POS receive>
  <OBJ: e_notice
       PRP=NIL
       SLK=receives
  JBO>
TVE>

------------------------------
Ex.2
Surface:
A special order has been established to award all veteran dogs who lost their tails in the battle or had their ear bit off in a skirmish.

FSP:
<ENB
  ID: e_order
  surface: "a special order"
  NS: dom.military.administration
BNE>

<ENB
  ID: e_tail
  surface: "tails"
  NS: dom.anatomy.bodypart
BNE>

<ENB
  ID: e_ear
  surface: "ear"
  NS: dom.anatomy.bodypart
BNE>

<ENB
  ID: e_battle
  surface: "the battle"
  NS: dom.military.event
BNE>

<ENB
  ID: e_skirmish
  surface: "a skirmish"
  NS: dom.military.event
BNE>

<QTF 
  Q=ALL 
  SET:s_dogs 
  PRM:f_dog 
  NS:dom.animals.canine 
  SEL=OR_1

  <EVT:id=E1
    <SBJ: f_dog>
    <ACT:PAST:INDF:ACTV:IDCT:NIL:POS lose>
    <OBJ: e_tail
         PRP=NIL
         SLK=loses
    JBO>
    <CRA: t_battle CLS: time>
  TVE>

  <EVT:id=E2
    <SBJ: f_dog>
    <ACT:PAST:INDF:PSSV:IDCT:NIL:POS bite_off>
    <OBJ: e_ear
         PRP=NIL
         SLK=affected
    JBO>
    <CRA: t_skirmish CLS: time>
  TVE>

  <LGK OR_1 E1 E2 KGL>
FTQ>

<EVT:id=E3
  <SBJ: e_order>
  <ACT:PAST:PERF:PSSV:IDCT:NIL:POS establish INF:award PRN:preparation AGC:internal RLZ:projected>
  <OBJ: s_dogs
       PRP=NIL
       SLK=recipient
  JBO>
TVE>

------------------------------
Ex.3
Surface:
Every operative who participated in the desert op had been trained by an assigned expert who had combat experience in the desert.

FSP:
<ENB
  ID: e_desert_op
  surface: "the desert op"
  NS: dom.intelligence.operation
ENT>

<ENB
  ID: e_experience
  surface: "combat experience in the desert"
  NS: dom.military.experience
ENT>

<QTF 
  Q=ALL 
  SET: s_operatives 
  PRM: f_op 
  NS: dom.intelligence.personnel 
  SEL=E1

  <EVT: id=E1
    <SBJ: f_op>
    <ACT: PST:INDF:ACTV:IDCT:NIL:POS participate>
    <OBJ: e_desert_op
         PRP=NIL
         SLK=participates_in
    JBO>
  EVT>
QTF>

<QTF 
  Q=EXIST
  PTR: x_expert
  PRM: f_exp
  NS: dom.intelligence.expert
  SEL=E2

  <EVT: id=E2
    <SBJ: f_exp>
    <ACT: PST:INDF:ACTV:IDCT:NIL:POS have>
    <OBJ: e_experience
         PRP=NIL
         SLK=has
    JBO>
  EVT>
QTF>

<EVT: id=E3
  <SBJ: s_operatives>
  <ACT: PST:PERF:PSSV:IDCT:NIL:POS train>
  <OBJ: NIL>
  <BY: x_expert>
EVT>

<ENB
    ID: e_experience
    surface: "combat experience in the desert"
    NS: dom.military.experience
  ENT>
  <MSE
  ...
  ESM>
BNE>

------------------------------
Ex.4
Surface:
All employees who don't have a manager report directly to the vice-president.

FSP:
<ENB
  ID: e_vp
  surface: "the vice-president"
  NS: dom.corporate.position
BNE>

<QTF
  T=EXIST
  PTR:x_mgr
  PRM:f_mgr
  NS:dom.corporate.role
  SEL=E0

  <EVT:id=E0
    <SBJ:f_mgr>
    <ACT:NIL:INDF:STV:IDCT:NIL:POS exist>
  EVT>
QTF>

<QTF
  T=ALL
  SET:s_employees
  PRM:f_emp
  NS:dom.corporate.personnel
  SEL=E1

  <EVT:id=E1
    <SBJ:f_emp>
    <ACT:PRST:INDF:ACTV:IDCT:NIL:NEG have>
    <OBJ:x_mgr
         PRP=NIL
         SLK=has
    JBO>
  EVT>
QTF>

CRB>
  ID:c_directly
  surface:"directly"
  CLS:manner
BRC>

<EVT:id=E2
  <SBJ:s_employees>
  <ACT:PRST:INDF:ACTV:IDCT:NIL:POS report>
  <CRA:c_directly CLS:manner>
  <OBJ:e_vp
       PRP=to
       SLK=reports_to
  JBO>
EVT>
--------------------------------------------------------------
6.5 Set Algebra and Result Sets
--------------------------------------------------------------

Simple set operations are expressed with SETOP:

  <SETOP: INTER s_A s_B AS s_C>   // intersection
  <SETOP: UNION s_A s_B AS s_C>   // union
  <SETOP: DIFF  s_A s_B AS s_C>   // s_A \ s_B
  <SETOP: COMP  s_U s_A AS s_C>   // complement of s_A in universe s_U

These operators are purely intensional at the FREGE layer; profiles
may reify the results as additional SET nodes if needed.

s_C is the identifier of the Result Set that have no operational differences
from sets declared in SET block.

--------------------------------------------------------------
7. ROUTINES (RTN) AND PLANNED EVENTS
--------------------------------------------------------------

### 7.1 RTN ‚Äì Routine

RTN defines a plan, procedure, or playbook as a named construct
consisting of:

  ‚Ä¢ optional local SET blocks,
  ‚Ä¢ PLE (planned event) blocks,
  ‚Ä¢ EDGE blocks expressing order and logical relations between PLEs.

Formal syntax:

  <RTN: rtn_name
      [<NS: ...>]
      [local SET blocks]
      [PLE blocks]
      [CNJ blocks] | [LGK blocks]
  NTR>

RTN itself may be reified as a node in the global DAG (type=RTN)
by profiles that need to track or reason about routines as objects.

--------------------------------------------------------------
7.2 PLE ‚Äì Planned Event
--------------------------------------------------------------

PLE mirrors EVT but uses PLA instead of ACT to indicate planned
rather than realized events. The internal structure of PLA is
identical to ACT (TNS/ASP/MOO/MDL + lemma). OBJ blocks use the
same PRP/SLK schema.

Formal syntax:

  <PLE:id=Ev_*
      <SBJ: nodeid>
      <PLA:TNS:ASP:MOO:MDL lemma>
      [OBJ-BLOCK ‚Ä¶]
  ELP>

Where:

  nodeid ::= e_* | s_* | f_*

OBJ-BLOCK inside PLE:

  <OBJ: nodeid
       PRP=preposition_or_NIL
       SLK=semantic_link
  JBO>

Semantics of OBJ are identical to EVT: SBJ --SLK--> OBJ.

======================================================================
DUAL ENCODING STANDARD (VERBOSE MODE ‚Üî COMPACT MODE)
======================================================================

8.1 Purpose
------------
FREGE-2.1 supports two interchangeable textual encodings of the same
semantic graph:

  ‚Ä¢ Verbose Mode   ‚Äî human-readable, multi-line, indented
  ‚Ä¢ Compact Mode   ‚Äî machine-optimized, single-line, minimal whitespace

Both encodings are fully canonical, fully reversible, and structurally
isomorphic. 
Whitespace and indentation have *no syntactic significance* in FREGE.
Block boundaries are defined solely by explicit open/close tags.

----------------------------------------------------------------------
8.2 Verbose Encoding Mode (Human-Readable)
----------------------------------------------------------------------

Definition:
    Verbose Mode uses:
      ‚Ä¢ newlines to separate structural units
      ‚Ä¢ indentation to visualize nesting depth
      ‚Ä¢ optional spacing around attributes
      ‚Ä¢ the exact same tags as Compact Mode

Characteristics:
    ‚úì ideal for debugging, audits, manual review  
    ‚úì structurally explicit  
    ‚úì line-oriented  
    ‚úì easier for humans to inspect

Example:
    <EVT:id=E1
        <SBJ:e_smell>
        <ACT:PAST:NIL:ATV:IDCT:NIL:POS remind>
        <OBJ:e_Nathan PRP=NIL SLK=affects JBO>
        <OBJ:e_childhood PRP="of" SLK=has.association JBO>
    TVE>

MANDATORY RULE:
In Verbose Mode the name of EVERY variable declared by ANY block 
MUST reflect the EXACT SURFACE VERBIAGE concatenated with `_`.
Breaking this rule invalidates the verbose DFS immediately!

----------------------------------------------------------------------
8.3 Compact Encoding Mode (Single-Line)
----------------------------------------------------------------------

Definition:
    Compact Mode removes:
      ‚Ä¢ all newlines
      ‚Ä¢ all indentation
      ‚Ä¢ all unnecessary whitespace

Only minimal spacing is kept where required by lexical safety.

Characteristics:
    ‚úì one physical line per entire sentence  
    ‚úì minimal size  
    ‚úì fast to parse  
    ‚úì ideal for storage, indexing, and search

Example:
[WGNR|00CF]<ENB: ID: e_sample surface: "This sample" NS: dom.intelligence.datasetBNE><ENB: ID: e_individuals surface: "all individuals who submitted details to the fake military contractor" NS: dom.human.populationBNE><ENB: ID: e_contractor surface: "the fake military contractor" NS: dom.military.organizationBNE><ENB: ID: e_mercenaries surface: "every mercenary arrested in Minsk by Belarusian security" NS: dom.military.personnelBNE><ENB: ID: e_Minsk surface: "Minsk" NS: dom.geography.cityBNE><ENB: ID: e_Belarus_security surface: "Belarusian security" NS: dom.national.securityBNE><ENB <ENB: ID: e_portion surface: "roughly 40 percent of all individuals who submitted details to the fake military contractor" NS: dom.statistics.coverage BNE> CSV>BNE> <EVT:id=E1 <SBJ: e_individuals> <ACT:PAST:INDF:ACTV:IDCT:NIL:POS submit> <OBJ: e_contractor PRP=to SLK=recipient JBO> <OBJ: NIL PRP=NIL SLK=submits JBO>TVE><EVT:id=E2 <SBJ: e_sample> <ACT:PAST:INDF:ACTV:IDCT:NIL:POS cover> <OBJ: e_portion PRP=NIL SLK=covers JBO>TVE><EVT:id=E3 <SBJ: e_Belarus_security> <ACT:PAST:INDF:ACTV:IDCT:NIL:POS arrest> <OBJ: e_mercenaries PRP=NIL SLK=affects JBO> <OBJ: e_Minsk PRP=in SLK=location JBO>TVE><EVT:id=E4 <SBJ: e_sample> <ACT:PAST:INDF:ACTV:IDCT:NIL:POS encompass> <OBJ: e_mercenaries PRP=NIL SLK=includes JBO>TVE><CNJ E2 E1 "who" explanatory JNC><CNJ E4 E3 "arrested in" explanatory JNC>

MANDATORY:
Empty lines between FSP lines are strictly forbidden!

This is semantically and structurally equivalent to the Verbose version.

----------------------------------------------------------------------
8.4 Syntactic Safety Guarantees
----------------------------------------------------------------------

Both formats rely on FREGE‚Äôs explicit structural markers:

    ‚Ä¢ Unique open tags (e.g., <EVT, <OBJ, <ENB, <QTF)
    ‚Ä¢ Unique asymmetric close tags (TVE>, TNP>, TL>, TE>, etc.)
    ‚Ä¢ Deterministic OBJ closure using JBO
    ‚Ä¢ Strict attribute grammar (PRP=‚Ä¶, SLK=‚Ä¶)

Because of these explicit markers, no structural ambiguity can arise.
Whitespace is never required to determine block boundaries.

Thus:
    ‚Ä¢ Removing indentation is safe.
    ‚Ä¢ Removing newlines is safe.
    ‚Ä¢ Collapsing spaces is safe (except where token separation is needed).

----------------------------------------------------------------------
8.6 Transformation Algorithms
----------------------------------------------------------------------

A. Decompression:
    - Scan input for '<'
    - On each '<TAG', start a new line
    - Track depth using open/close tags
    - Indent by depth
    - Output closing tags as standalone tokens

B. Compression:
    - Strip all indentation
    - Strip all newline characters
    - Normalize spaces to a minimum set
    - Ensure `<TAG...>` boundaries remain intact

Both algorithms are linear-time O(n).

----------------------------------------------------------------------
8.7 Encoding Mode Selection
----------------------------------------------------------------------

Applications may choose mode as follows:

    Verbose:
        - debugging FSP-2 profiles
        - human-facing UIs
        - education and audits

    Compact:
        - corpus-level FSP storage
        - transmitting FREGE profiles in workflows
        - large-scale semantic indexing/querying
        - model-to-model communication

Both modes are first-class citizens of FREGE-2.1.
Neither is ‚Äúintermediate‚Äù; both are canonical.

----------------------------------------------------------------------
8.8 Standardization Note
----------------------------------------------------------------------

Profiles MAY contain any mixture of Verbose and Compact blocks.


----------------------------------------------------------------------
8.9 Summary
----------------------------------------------------------------------

FREGE-2.1 supports dual-mode encoding:

    Verbose Mode  ‚Äî full readability
    Compact Mode  ‚Äî full density

The transformation is fully reversible and deterministic due to explicit,
unambiguous start/end tags.

This design maintains reversibility, syntactic safety, and maximal
efficiency without sacrificing the expressiveness of the FREGE-2.1 graph.
